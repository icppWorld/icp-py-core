"""
Test cases for VarT (type reference) handling in service definitions.

This test file demonstrates and verifies the fix for a bug where DID files
using type references for service definitions fail to parse.

Issue: When a Candid DID file defines the service entry point as a reference
to a named type (e.g., `service : () -> MyServiceType`), the Rust parser
returns `actor: null` and the Python `DIDLoader` raises
"DID content does not contain any methods".

This pattern is common in DID files generated by Motoko and is valid Candid syntax.
"""

import sys
import os
import unittest

# Add src directory to path
project_root = os.path.join(os.path.dirname(__file__), '..')
src_path = os.path.join(project_root, 'src')
sys.path.insert(0, src_path)

from icp_candid.did_loader import DIDLoader


class TestVarTServiceReference(unittest.TestCase):
    """Test cases for service definitions using type references (VarT)."""

    def test_inline_service_works(self):
        """Test that inline service definition works (baseline)."""
        did_code = """
service : {
    greet: (text) -> (text);
    health: () -> (bool) query;
}
"""
        loader = DIDLoader()
        result = loader.load_did_source(did_code)

        self.assertIsNotNone(result)
        methods = result.get("methods", {})
        self.assertEqual(len(methods), 2)
        self.assertIn("greet", methods)
        self.assertIn("health", methods)

    def test_class_with_inline_service_works(self):
        """Test that class with inline service works (baseline)."""
        did_code = """
type Config = record {
    name: text;
};

service : (opt Config) -> {
    greet: (text) -> (text);
    health: () -> (bool) query;
}
"""
        loader = DIDLoader()
        result = loader.load_did_source(did_code)

        self.assertIsNotNone(result)
        methods = result.get("methods", {})
        self.assertEqual(len(methods), 2)
        self.assertIn("greet", methods)
        self.assertIn("health", methods)

        # Verify init arguments are captured
        init_args = result.get("arguments", [])
        self.assertEqual(len(init_args), 1)

    def test_vart_service_reference_simple(self):
        """
        Test that service defined via type reference works.

        This is the primary test case for the VarT bug fix.
        Pattern: service : () -> TypeName
        """
        did_code = """
type GreetingService = service {
    greet: (text) -> (text);
    health: () -> (bool) query;
};

service : () -> GreetingService
"""
        loader = DIDLoader()
        result = loader.load_did_source(did_code)

        self.assertIsNotNone(result)
        methods = result.get("methods", {})
        self.assertEqual(len(methods), 2,
            "Expected 2 methods but got {}. This indicates the VarT bug.".format(len(methods)))
        self.assertIn("greet", methods)
        self.assertIn("health", methods)

        # Verify health is a query method
        health_method = methods["health"]
        self.assertIn("query", health_method.annotations)

    def test_vart_service_reference_with_init_args(self):
        """
        Test that service with init args defined via type reference works.

        Pattern: service : (args) -> TypeName
        """
        did_code = """
type Config = record {
    debug: bool;
};

type MyService = service {
    configure: (Config) -> ();
    get_status: () -> (text) query;
};

service : (opt Config) -> MyService
"""
        loader = DIDLoader()
        result = loader.load_did_source(did_code)

        self.assertIsNotNone(result)
        methods = result.get("methods", {})
        self.assertEqual(len(methods), 2,
            "Expected 2 methods but got {}. VarT with init args not handled.".format(len(methods)))
        self.assertIn("configure", methods)
        self.assertIn("get_status", methods)

        # Verify init arguments are captured
        init_args = result.get("arguments", [])
        self.assertEqual(len(init_args), 1)

    def test_vart_service_complex_methods(self):
        """Test VarT service with complex method signatures."""
        did_code = """
type User = record {
    id: nat64;
    name: text;
    email: opt text;
};

type CreateUserResult = variant {
    Ok: User;
    Err: text;
};

type UserService = service {
    create_user: (text, text) -> (CreateUserResult);
    get_user: (nat64) -> (opt User) query;
    list_users: () -> (vec User) query;
    delete_user: (nat64) -> (bool);
};

service : () -> UserService
"""
        loader = DIDLoader()
        result = loader.load_did_source(did_code)

        self.assertIsNotNone(result)
        methods = result.get("methods", {})
        self.assertEqual(len(methods), 4,
            "Expected 4 methods but got {}".format(len(methods)))
        self.assertIn("create_user", methods)
        self.assertIn("get_user", methods)
        self.assertIn("list_users", methods)
        self.assertIn("delete_user", methods)

        # Verify query annotations
        self.assertIn("query", methods["get_user"].annotations)
        self.assertIn("query", methods["list_users"].annotations)
        self.assertNotIn("query", methods["create_user"].annotations)
        self.assertNotIn("query", methods["delete_user"].annotations)

    def test_vart_motoko_style_canister(self):
        """
        Test a Motoko-style canister DID with type reference.

        This mimics the structure commonly generated by Motoko canisters.
        (Real world example are the mAIner canisters of funnAI.)
        """
        did_code = """
type MainerStatistics = record {
    total_mainers: nat64;
    active_mainers: nat64;
    last_updated: nat64;
};

type IssueFlags = record {
    maintenance_mode: bool;
    paused: bool;
};

type MainerAgentCtrlbCanister = service {
    getMainerStatisticsAdmin: () -> (MainerStatistics) query;
    getIssueFlagsAdmin: () -> (IssueFlags) query;
    setMaintenanceMode: (bool) -> ();
};

service : () -> MainerAgentCtrlbCanister
"""
        loader = DIDLoader()
        result = loader.load_did_source(did_code)

        self.assertIsNotNone(result)
        methods = result.get("methods", {})
        self.assertEqual(len(methods), 3,
            "Expected 3 methods but got {}".format(len(methods)))
        self.assertIn("getMainerStatisticsAdmin", methods)
        self.assertIn("getIssueFlagsAdmin", methods)
        self.assertIn("setMaintenanceMode", methods)


class TestVarTEdgeCases(unittest.TestCase):
    """Edge cases and error handling for VarT service references."""

    def test_vart_empty_service(self):
        """Test VarT reference to an empty service."""
        did_code = """
type EmptyService = service {};

service : () -> EmptyService
"""
        loader = DIDLoader()
        result = loader.load_did_source(did_code)

        self.assertIsNotNone(result)
        methods = result.get("methods", {})
        self.assertEqual(len(methods), 0)

    def test_vart_single_method(self):
        """Test VarT reference to a service with single method."""
        did_code = """
type SingleMethodService = service {
    ping: () -> (text);
};

service : () -> SingleMethodService
"""
        loader = DIDLoader()
        result = loader.load_did_source(did_code)

        self.assertIsNotNone(result)
        methods = result.get("methods", {})
        self.assertEqual(len(methods), 1)
        self.assertIn("ping", methods)


if __name__ == '__main__':
    unittest.main()
<<<<<<< Updated upstream
=======

>>>>>>> Stashed changes
